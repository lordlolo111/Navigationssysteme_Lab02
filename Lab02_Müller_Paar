### Lab02 Navigationssysteme - Pedestrian Dead Reckoning ###

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.signal import find_peaks
from scipy.signal import savgol_filter
from pathlib import Path
import contextily as ctx
from pyproj import Transformer

# Datenimport
dir = Path(__file__).resolve().parent
folder = Path(dir)/"Daten"/"DatenRaw"

acc = pd.read_csv(os.path.join(folder, 'accelerometer.csv'))
gyro = pd.read_csv(os.path.join(folder, 'gyroscope.csv'))
mag = pd.read_csv(os.path.join(folder, 'magnetometer.csv'))
baro = pd.read_csv(os.path.join(folder, 'barometer.csv'))
ori = pd.read_csv(os.path.join(folder, 'referenceOrientation.csv'))
ground_truth = pd.read_csv(os.path.join(folder, 'groundTruth.csv'))

# Umwandlung der Zeit von ms in Sekundnen
acc['time'] = acc['time'] / 1000
baro['time'] = baro['time'] / 1000
ori['time'] = ori['time'] / 1000
print(acc.head())
acc['acc_total'] = np.sqrt((acc['acc_x']**2)+(acc['acc_y']**2)+(acc['acc_z']**2)) # berechnet die Gesamtbeschleunigung pro Sekunde
print(acc.head())

# zuerst Filtern --> dann berechnen (Savitzky-Golay Filter) (https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.savgol_filter.html)
acc['acc_total_filtered'] = savgol_filter(acc['acc_total'], window_length= 21, polyorder= 3)


# Schritterfassung -- Berechnung (https://dganesan.github.io/mhealth-course/chapter2-steps/ch2-stepcounter.html)
peaks, _ = find_peaks(acc['acc_total_filtered'], height=1, distance=100, prominence= 0.5, width= 2) # Distance zw. 50 und 100 bei 100Hz-Intervall


plt.figure(figsize=(10, 4))

# Beschleunigung über Zeit mit & ohne Filter
plt.plot(acc['time'], acc['acc_total'], alpha=0.4, label='Raw acceleration')
plt.plot(acc['time'], acc['acc_total_filtered'], label='Filtered acceleration')

# Erkannte Schritte (Peaks) über Zeit
plt.plot(
    acc['time'].iloc[peaks],
    acc['acc_total_filtered'].iloc[peaks],
    "x",
    label='Detected steps'
)

plt.xlabel("Time [s]")
plt.ylabel("Acceleration [m/s²]")
plt.title("Step Detection: Filtered Total acceleration")
plt.legend()
plt.grid(True)
plt.show()

# Höhenabschätzung
p0 = baro['pressure'].iloc[0] # vorherrschendre Druck an der Ausgangsposition
# Formel für die Höhenberechnung auf Basis der barometrischen Daten
baro['height'] = (293.15 / (6.5e-3))* (
    (baro['pressure']/ p0) ** (-0.1903) - 1
)
#Anwendung des Savitzky-Golay Filters für die Höhe (same wie bei der Schrittlänge)
baro['height_filtered'] = savgol_filter(baro['height'], window_length= 21, polyorder= 3)

#Visualisierung der Höhendaten
plt.figure(figsize=(10,4))
plt.plot(baro['time'], baro['height'], alpha=0.4, label='Raw height')
plt.plot(baro['time'], baro['height_filtered'], label='Filtered height')

plt.xlabel("Time [s]")
plt.ylabel("Relative height [m]")
plt.title("Relative height estimation from barometer data")
plt.legend()
plt.grid(True)
plt.show()

#Grobe Schätzung der Schritte
step_count = (len(peaks)) # 133 Schritte ??

time_max = acc['time'].max()
time_min = acc['time'].min()
duration = int(time_max) - int(time_min)
duration_minutes = duration/60
steps_per_sec = (step_count)/duration
print("\nNumber of steps (Estimation):", step_count)
print(f"The walk lasted for: {duration_minutes} minutes")
print(f"Steps per Seconds: {steps_per_sec:.2f}")

#Schrittlänge Schätzung
#Weinberg Model

acc_valleys = []

for i, peak in enumerate(peaks):
    if i == 0:
        # erstes Minimum von Start bis erster Peak
        valley = acc['acc_total'].iloc[:peak+1].min()
    else:
        # Minimum zwischen vorherigem und aktuellem Peak
        valley = acc['acc_total'].iloc[peaks[i-1]:peak+1].min()
    acc_valleys.append(valley)

k = 0.4 # empirischer Faktor
step_lengths = []

for i, peak in enumerate(peaks):
    step_len = k * (acc['acc_total'].iloc[peak] - acc_valleys[i])**0.25
    step_lengths.append(step_len)

# Gesamtdistanz
total_distance = np.sum(step_lengths)
print("Estimated distance (Weinberg-Model):", total_distance, "m")

# Anpassung der Schrittlängen Schätzung inklusive der Höhendaten --> Stiegen z.b.

height_at_peak = np.interp( #Interpoliert Höhe an Stelle der Schritt-Peak-Zeitpunkte
    acc['time'].iloc[peaks], 
    baro['time'],
    baro['height_filtered']
)

# Angepasste Schrittweite
k = 0.4  # Weinberg Faktor
step_lengths_adjusted = []
for i, peak in enumerate(peaks):
    # Weinberg-Schritt
    step_len = k * (acc['acc_total_filtered'].iloc[peak] - acc_valleys[i])**0.25
    # Stiegenerkennung: Δh > 0.15 m → Treppe
    if i > 0:
        delta_h = height_at_peak[i] - height_at_peak[i-1]
        if abs(delta_h) > 0.15:  # Schwelle in m
            step_len = 0.3  # verkürzte Schrittweite bei Treppe
    step_lengths_adjusted.append(step_len)

# Gesamtdistanz
total_distance_adjusted = np.sum(step_lengths_adjusted)
print("Estimated distance with stairs adjustment:", total_distance_adjusted, "m")

# Visualization of stair adjustment
plt.figure(figsize=(10,4))
plt.plot(range(len(step_lengths_adjusted)), step_lengths_adjusted, '-o')
plt.xlabel("Step index")
plt.ylabel("Step length [m]")
plt.title("Step lengths with stair adjustment")
plt.grid(True)
plt.show()

#Direction estimation:
#Berechnung Roll & Pitch:
roll = np.arctan2(
    -acc['acc_x'],
    -acc['acc_z']
)

pitch = np.arctan2(
    acc['acc_y'],
    np.sqrt(acc['acc_x']**2 + acc['acc_z']**2)
)

# Yaw estimation:
yaw = np.arctan2(
    -mag['mag_x'] * np.cos(roll) + mag['mag_z'] * np.sin(roll),
     mag['mag_y'] * np.cos(pitch)
     + mag['mag_x'] * np.sin(pitch) * np.sin(roll)
     + mag['mag_z'] * np.sin(pitch) * np.cos(roll)
)
#Normalisierung:
yaw = (yaw + np.pi) % (2 * np.pi) - np.pi

#---------------------------------------------------------------------------#
# Startpunkt
lat0, lon0 = 47.06422, 15.45291  # Startkoordinaten in Grad
R = 6378137  # Erdradius

# ----------------------
# Schrittweite und Richtung: N/E berechnen
N = np.cumsum([sl * np.cos(yaw[peaks[i]]) for i, sl in enumerate(step_lengths)])
E = np.cumsum([sl * np.sin(yaw[peaks[i]]) for i, sl in enumerate(step_lengths)])

# Startpunkt hinzufügen
N = np.insert(N, 0, 0)
E = np.insert(E, 0, 0)

lat = lat0 + N / R * (180/np.pi)
lon = lon0 + E / (R * np.cos(lat0*np.pi/180)) * (180/np.pi)



# ----------------------
# Projektion: WGS84 → Web Mercator
transformer = Transformer.from_crs("EPSG:4326", "EPSG:3857", always_xy=True)
x, y = transformer.transform(lon, lat)
x0, y0 = transformer.transform(lon0, lat0)

# ----------------------
# Visualisierung mit Basemap
plt.figure(figsize=(9,9))
plt.plot(x, y, 'o-', label='Estimated Path')
plt.scatter(x0, y0, color='green', s=100, label='Start')
ax = plt.gca()
ctx.add_basemap(ax, source=ctx.providers.OpenStreetMap.Mapnik)
plt.xlabel('East [m]')
plt.ylabel('North [m]')
plt.title('Pedestrian Dead Reckoning with Basemap')
plt.ticklabel_format(style='plain', useOffset=False)
plt.legend()
plt.grid(True)
plt.axis('equal')
plt.show()

