### Lab02 Navigationssysteme - Pedestrian Dead Reckoning ###

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.signal import find_peaks

# Datenimport
folder = "Daten/DatenRaw"

acc = pd.read_csv(os.path.join(folder, 'accelerometer.csv'))
gyro = pd.read_csv(os.path.join(folder, 'gyroscope.csv'))
mag = pd.read_csv(os.path.join(folder, 'magnetometer.csv'))
baro = pd.read_csv(os.path.join(folder, 'barometer.csv'))
ori = pd.read_csv(os.path.join(folder, 'referenceOrientation.csv'))
ground_truth = pd.read_csv(os.path.join(folder, 'groundTruth.csv'))

# Umwandlung der Zeit von ms in Sekundnen
acc['time'] = acc['time'] / 1000
baro['time'] = baro['time'] / 1000
ori['time'] = ori['time'] / 1000
print(acc.head())
acc['acc_total'] = np.sqrt((acc['acc_x']**2)+(acc['acc_y']**2)+(acc['acc_z']**2)) # berechnet die Gesamtbeschleunigung pro Sekunde
print(acc.head())

# zuerst Filtern --> dann berechnen
#

# Schritterfassung -- Berechnung (https://dganesan.github.io/mhealth-course/chapter2-steps/ch2-stepcounter.html)
peaks, _ = find_peaks(acc['acc_total'], height=1, distance=100, prominence= 0.5, width= 2) # Distance zw. 50 und 100 bei 100Hz-Intervall


plt.figure(figsize=(10, 4))

# Beschleunigung über Zeit
plt.plot(acc['time'], acc['acc_total'], label='Acceleration')

# Erkannte Schritte (Peaks) über Zeit
plt.plot(
    acc['time'].iloc[peaks],
    acc['acc_total'].iloc[peaks],
    "x",
    label='Detected steps'
)

plt.xlabel("Time [s]")
plt.ylabel("Acceleration [m/s²]")
plt.title("Step Detection: total acceleration")
plt.legend()
plt.grid(True)
plt.show()

#Grobe Schätzung der Schritte
step_count = (len(peaks)) # 133 Schritte ??

time_max = acc['time'].max()
time_min = acc['time'].min()
duration = int(time_max) - int(time_min)
duration_minutes = duration/60
steps_per_sec = (step_count)/duration
print("\nNumber of steps (Estimation):", step_count)
print(f"The walk lasted for: {duration_minutes} minutes")
print(f"Steps per Seconds: {steps_per_sec:.2f}")

#Schrittlänge Schätzung
#Weinberg Model

acc_valleys = []

for i, peak in enumerate(peaks):
    if i == 0:
        # erstes Minimum von Start bis erster Peak
        valley = acc['acc_total'].iloc[:peak+1].min()
    else:
        # Minimum zwischen vorherigem und aktuellem Peak
        valley = acc['acc_total'].iloc[peaks[i-1]:peak+1].min()
    acc_valleys.append(valley)

k = 0.4 # empirischer Faktor
step_lengths = []

for i, peak in enumerate(peaks):
    step_len = k * (acc['acc_total'].iloc[peak] - acc_valleys[i])**0.25
    step_lengths.append(step_len)

# Gesamtdistanz
total_distance = np.sum(step_lengths)
print("Estimated distance (Weinberg-Model):", total_distance, "m")

#Direction estimation:
#Berechnung Roll & Pitch:
roll = np.arctan2(
    -acc['acc_x'],
    -acc['acc_z']
)

pitch = np.arctan2(
    acc['acc_y'],
    np.sqrt(acc['acc_x']**2 + acc['acc_z']**2)
)

# Yaw estimation:
yaw = np.arctan2(
    -mag['mag_x'] * np.cos(roll) + mag['mag_z'] * np.sin(roll),
     mag['mag_y'] * np.cos(pitch)
     + mag['mag_x'] * np.sin(pitch) * np.sin(roll)
     + mag['mag_z'] * np.sin(pitch) * np.cos(roll)
)
#Normalisierung:
yaw = (yaw + np.pi) % (2 * np.pi) - np.pi

#---------------------------------------------------------------------------#

# Startpunkt
lat0, lon0 = 47.06422, 15.45291  # Startkoordinaten in Grad
R = 6378137  # Erdradius WGS84 in Metern

# ----------------------
# Schrittweite und Richtung: N/E berechnen
N = np.cumsum([sl * np.cos(yaw[peaks[i]]) for i, sl in enumerate(step_lengths)])
E = np.cumsum([sl * np.sin(yaw[peaks[i]]) for i, sl in enumerate(step_lengths)])

# Startpunkt hinzufügen
N = np.insert(N, 0, 0)
E = np.insert(E, 0, 0)


lat = lat0 + N / R * (180/np.pi)
lon = lon0 + E / (R * np.cos(lat0*np.pi/180)) * (180/np.pi)


# Visualisierung
plt.figure(figsize=(8,8))
plt.plot(lon, lat, 'o-', label='Estimated Path')
plt.scatter(lon0, lat0, color='green', s=100, label='Start')
plt.xlabel('Longitude [°]')
plt.ylabel('Latitude [°]')
plt.title('Pedestrian Dead Reckoning: Estimated Path in Lat/Lon')
plt.legend()
plt.grid(True)

# Achsenbereich dynamisch setzen (FUNKTIONIERT NOCH NICHT)
margin_lat = (lat.max() - lat.min()) * 0.1
margin_lon = (lon.max() - lon.min()) * 0.1
plt.xlim(lon.min() - margin_lon, lon.max() + margin_lon)
plt.ylim(lat.min() - margin_lat, lat.max() + margin_lat)
plt.show()

# ----------------------
# Step Counting
step_count = len(step_lengths)
print("Number of steps detected:", step_count)
print("Estimated distance (Weinberg-Model):", np.sum(step_lengths), "m")
